<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ぷよぷよ風パズル（HTML/JSのみ）</title>
<meta name="robots" content="noindex,nofollow" />
<style>
  :root{
    --bg:#0b0b0b; --panel:#121212; --fg:#fff; --muted:#bdbdbd; --acc:#3dd5f3;
    --cell:32px;
  }
  *{box-sizing:border-box; user-select:none;}
  html,body{margin:0; padding:0; background:var(--bg); color:var(--fg); font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans JP",sans-serif;}
  .wrap{
    min-height:100dvh; display:flex; align-items:center; justify-content:center; gap:16px; padding:16px;
  }
  .hud{
    width:min(92vw,360px); max-width:360px; background:var(--panel); border:1px solid #222; border-radius:12px; padding:12px 14px;
  }
  .hud h1{font-size:16px; margin:0 0 8px; color:#eaeaea;}
  .stats{display:grid; grid-template-columns:1fr 1fr; gap:8px; font-variant-numeric:tabular-nums;}
  .stats .card{background:#0e0e0e; border:1px solid #222; border-radius:10px; padding:10px;}
  .card .label{font-size:12px; color:var(--muted);}
  .card .value{font-size:20px; margin-top:4px;}
  .nextbox{display:flex; align-items:center; gap:10px;}
  .nextcanvas{border:1px solid #222; background:#0e0e0e; border-radius:8px;}
  .btnrow{margin-top:10px; display:flex; gap:8px; flex-wrap:wrap}
  button{
    appearance:none; border:1px solid #333; background:#1a1a1a; color:#fff; padding:10px 12px; border-radius:10px; font-size:14px; cursor:pointer;
  }
  button:active{transform:translateY(1px);}
  .boardWrap{
    position:relative; width:calc(var(--cell)*6); height:calc(var(--cell)*12);
    border-radius:12px; overflow:hidden; border:1px solid #222; background:linear-gradient(180deg,#0f0f0f,#0a0a0a);
    box-shadow:inset 0 0 0 2px rgba(255,255,255,0.03);
  }
  canvas#board{display:block; width:100%; height:100%;}
  .mobilePad{
    position:fixed; left:0; right:0; bottom:8px; display:flex; justify-content:center; gap:10px; z-index:10;
  }
  .mobilePad .pad{
    display:flex; gap:8px; background:rgba(18,18,18,.9); border:1px solid #222; border-radius:14px; padding:10px;
    backdrop-filter: blur(6px);
  }
  .mobilePad .pad button{min-width:48px; min-height:48px; font-size:18px; border-radius:12px;}
  .toast{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none;
    font-weight:700; letter-spacing:1px; text-shadow:0 2px 8px rgba(0,0,0,.6);
  }
  .chainPop{
    font-size:36px; color:#ffe600; opacity:0; transform:translateY(8px) scale(0.95);
    transition: all .35s ease;
  }
  .chainPop.show{opacity:1; transform:translateY(0) scale(1);}
  .gameover{
    position:absolute; inset:0; background:rgba(0,0,0,.55); display:flex; align-items:center; justify-content:center; text-align:center; padding:20px;
  }
  .gameover .panel{
    background:#131313; border:1px solid #222; border-radius:12px; padding:16px 18px; width:min(90vw,340px);
  }
  .gameover h2{margin:0 0 6px; font-size:18px;}
  .gameover p{margin:2px 0 12px; color:var(--muted);}
  .gameover .row{display:flex; gap:8px; justify-content:center; flex-wrap:wrap;}
  .hint{font-size:12px; color:var(--muted); margin-top:8px}
  .link{color:var(--acc); text-decoration:none}
</style>
</head>
<body>
<div class="wrap">
  <div class="boardWrap">
    <canvas id="board"></canvas>
    <div class="toast"><div id="chainPop" class="chainPop"></div></div>
    <div id="overlay" class="gameover" style="display:none;">
      <div class="panel">
        <h2>Game Over</h2>
        <p>スコア: <span id="finalScore">0</span> / 最高連鎖: <span id="finalMaxChain">0</span></p>
        <div class="row">
          <button id="btnRestart">もう一度</button>
        </div>
        <div class="hint">操作: ← → / Z(左回転) X(右回転) / ↓ / Space</div>
      </div>
    </div>
  </div>

  <div class="hud">
    <h1>ぷよぷよ風 パズル</h1>
    <div class="stats">
      <div class="card"><div class="label">スコア</div><div id="score" class="value">0</div></div>
      <div class="card"><div class="label">連鎖</div><div id="chain" class="value">0</div></div>
      <div class="card nextbox" style="grid-column:1 / span 2;">
        <div class="label" style="margin-right:8px;">NEXT</div>
        <canvas id="next" class="nextcanvas" width="90" height="90"></canvas>
      </div>
    </div>
    <div class="btnrow">
      <button id="btnNew">新規ゲーム</button>
      <button id="btnPause">一時停止</button>
      <button id="btnHard">ハードドロップ</button>
    </div>
    <div class="hint">※シングル用の簡易版（おじゃま・対戦なし）。ローカル実行OK。</div>
  </div>
</div>

<!-- モバイル操作パッド -->
<div class="mobilePad" aria-hidden="false">
  <div class="pad">
    <button id="mLeft" aria-label="左">◀︎</button>
    <button id="mRight" aria-label="右">▶︎</button>
    <button id="mDown" aria-label="下">▼</button>
    <button id="mRotL" aria-label="左回転">⟲</button>
    <button id="mRotR" aria-label="右回転">⟳</button>
    <button id="mHard" aria-label="ハードドロップ">⤓</button>
  </div>
</div>

<script>
(() => {
  // ===== 基本設定 =====
  const COLS = 6;
  const ROWS = 12;
  const COLORS = 4; // 4色（増やすと難易度上がる）
  const GRAVITY_MS = 700;       // 自然落下間隔
  const SOFTDROP_MS = 60;       // ↓キー中の落下間隔
  const CLEAR_DELAY = 280;      // 消去演出待機
  const SPAWN_DELAY = 100;      // 次生成の待機(見た目の安定)
  const SCORE_PER = 10;         // 1個の基本点
  const COLOR_TABLE = {
    1:'#ff5468', // red
    2:'#5ab1ff', // blue
    3:'#59d37c', // green
    4:'#ffd769', // yellow
    5:'#b48cff', // (未使用: 5色目)
  };
  const ORIENTS = [
    {dx:0, dy:-1}, // 上
    {dx:1, dy:0},  // 右
    {dx:0, dy:1},  // 下
    {dx:-1, dy:0}, // 左
  ];

  // ===== 画面準備 =====
  const boardCanvas = document.getElementById('board');
  const nextCanvas  = document.getElementById('next');
  const scoreEl = document.getElementById('score');
  const chainEl = document.getElementById('chain');
  const popEl = document.getElementById('chainPop');
  const overlay = document.getElementById('overlay');
  const finalScoreEl = document.getElementById('finalScore');
  const finalMaxChainEl = document.getElementById('finalMaxChain');
  const btnRestart = document.getElementById('btnRestart');
  const btnNew = document.getElementById('btnNew');
  const btnPause = document.getElementById('btnPause');
  const btnHard = document.getElementById('btnHard');

  // Mobile buttons
  const mLeft = document.getElementById('mLeft');
  const mRight = document.getElementById('mRight');
  const mDown = document.getElementById('mDown');
  const mRotL = document.getElementById('mRotL');
  const mRotR = document.getElementById('mRotR');
  const mHard = document.getElementById('mHard');

  // Canvas 高解像度対応
  const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const CELL = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'));
  boardCanvas.width  = COLS * CELL * DPR;
  boardCanvas.height = ROWS * CELL * DPR;
  const ctx = boardCanvas.getContext('2d');
  ctx.scale(DPR, DPR);

  const nctx = nextCanvas.getContext('2d');

  // ===== ゲーム状態 =====
  const emptyBoard = () => Array.from({length:ROWS}, () => Array(COLS).fill(0));
  let board = emptyBoard();

  let rng = Math.random;
  const randInt = (a,b) => (a + Math.floor(rng()*(b-a+1)));

  const randColor = () => randInt(1, COLORS);

  let active = null; // {x,y, c1,c2, orient}
  let nextPair = [randColor(), randColor()];
  let dropTimer = 0;
  let dropInterval = GRAVITY_MS;
  let lastTime = 0;
  let playing = false;
  let paused = false;
  let clearing = false;
  let score = 0;
  let chain = 0;        // 現在の連鎖表示
  let maxChain = 0;     // このゲームの最大連鎖
  let gameover = false;

  function reset() {
    board = emptyBoard();
    nextPair = [randColor(), randColor()];
    active = null;
    dropTimer = 0;
    dropInterval = GRAVITY_MS;
    lastTime = 0;
    playing = true;
    paused = false;
    clearing = false;
    score = 0;
    chain = 0;
    maxChain = 0;
    gameover = false;
    overlay.style.display = 'none';
    scoreEl.textContent = '0';
    chainEl.textContent = '0';
    popEl.classList.remove('show');
    spawn();
    draw();
  }

  function spawn() {
    // ピボット(2,1) 子ぷよは初期「上」= y-1 => (2,0)
    active = { x:2, y:1, c1: nextPair[0], c2: nextPair[1], orient:0 };
    // 次を用意
    nextPair = [randColor(), randColor()];
    drawNext();
    // 即死チェック
    if (collides(active,0,0,active.orient)) {
      // 出現地点が塞がってる => ゲームオーバー
      endGame();
    }
  }

  function endGame() {
    playing = false; gameover = true;
    finalScoreEl.textContent = String(score);
    finalMaxChainEl.textContent = String(maxChain);
    overlay.style.display = 'flex';
  }

  // ===== 衝突判定 =====
  function getPieces(p, orient = p.orient){
    const o = ORIENTS[orient];
    return [
      {x:p.x, y:p.y, color:p.c1},
      {x:p.x + o.dx, y:p.y + o.dy, color:p.c2},
    ];
  }

  function collides(p, dx, dy, newOrient = p.orient) {
    const cells = getPieces(p, newOrient);
    for (const cell of cells) {
      const nx = cell.x + dx;
      const ny = cell.y + dy;
      if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
      if (ny >= 0 && board[ny][nx] !== 0) return true;
    }
    return false;
  }

  // ===== 操作 =====
  function move(dx) {
    if (!playing || paused || clearing) return;
    if (!collides(active, dx, 0, active.orient)) {
      active.x += dx;
      draw();
    }
  }

  function softDown() {
    if (!playing || paused || clearing) return;
    if (!collides(active, 0, 1, active.orient)) {
      active.y += 1;
      draw();
    } else {
      lockAndResolve();
    }
  }

  function hardDrop() {
    if (!playing || paused || clearing) return;
    let moved = false;
    while (!collides(active, 0, 1, active.orient)) {
      active.y += 1;
      moved = true;
    }
    draw();
    lockAndResolve();
  }

  function rotate(dir) {
    if (!playing || paused || clearing) return;
    const old = active.orient;
    const neo = (old + (dir>0 ? 1 : 3)) & 3;
    // 壁キック(簡易): そのまま→左→右→上
    if (!collides(active, 0, 0, neo)) {
      active.orient = neo;
    } else if (!collides(active, -1, 0, neo)) {
      active.x -= 1; active.orient = neo;
    } else if (!collides(active, 1, 0, neo)) {
      active.x += 1; active.orient = neo;
    } else if (!collides(active, 0, -1, neo)) {
      active.y -= 1; active.orient = neo;
    }
    draw();
  }

  // ===== 固定＆消去処理 =====
  function lockAndResolve() {
    // 盤面に固定
    const cells = getPieces(active);
    for (let i=0;i<cells.length;i++){
      const c = cells[i];
      if (c.y >= 0) board[c.y][c.x] = c.color;
      else {
        // 画面外に残って固定→即死
        endGame();
        return;
      }
    }
    active = null;
    // 連鎖検出
    resolveChains();
  }

  function resolveChains() {
    clearing = true;
    let anyCleared = false;
    let localChain = 0;
    const loop = () => {
      const toClear = findClusters(board);
      if (toClear.length === 0) {
        // 終了
        if (localChain > 0) {
          maxChain = Math.max(maxChain, localChain);
          showChainPop(localChain);
        }
        clearing = false;
        chain = 0;
        chainEl.textContent = '0';
        setTimeout(() => { if (!gameover) { spawn(); draw(); } }, SPAWN_DELAY);
        return;
      }
      anyCleared = true;
      localChain++;
      chain = localChain;
      chainEl.textContent = String(chain);

      // スコア加点 (個数×基本点×連鎖数)
      let clearedCount = 0;
      for (const [y,x] of toClear) { if (board[y][x]!==0) clearedCount++; }
      score += clearedCount * SCORE_PER * localChain;
      scoreEl.textContent = String(score);

      // 消去(演出: 点滅)
      blinkAndClear(toClear, () => {
        applyGravity(board);
        draw();
        setTimeout(loop, 40); // 次の連鎖チェック
      });
    };
    loop();
  }

  function findClusters(bd) {
    const visited = Array.from({length:ROWS},()=>Array(COLS).fill(false));
    const result = [];
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    for (let y=0;y<ROWS;y++){
      for (let x=0;x<COLS;x++){
        const color = bd[y][x];
        if (color===0 || visited[y][x]) continue;
        const q=[[y,x]];
        visited[y][x]=true;
        const group=[[y,x]];
        while(q.length){
          const [cy,cx]=q.pop();
          for(const [dx,dy] of dirs){
            const nx=cx+dx, ny=cy+dy;
            if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
            if(visited[ny][nx]) continue;
            if(bd[ny][nx]===color){
              visited[ny][nx]=true;
              q.push([ny,nx]); group.push([ny,nx]);
            }
          }
        }
        if (group.length>=4) result.push(...group);
      }
    }
    return result;
  }

  function blinkAndClear(cells, done){
    let on = true;
    const times = 2;
    let cnt = 0;
    const set = new Set(cells.map(([y,x]) => `${y},${x}`));
    const timer = setInterval(() => {
      on = !on;
      draw(set, on ? 0.4 : 1.0);
      cnt++;
      if (cnt>=times*2){
        clearInterval(timer);
        // 実消去
        for (const key of set){
          const [sy,sx] = key.split(',').map(Number);
          board[sy][sx]=0;
        }
        done();
      }
    }, CLEAR_DELAY/(times*2));
  }

  function applyGravity(bd){
    for (let x=0;x<COLS;x++){
      let write = ROWS-1;
      for (let y=ROWS-1;y>=0;y--){
        if (bd[y][x]!==0){
          const color = bd[y][x];
          if (y!==write){
            bd[write][x] = color;
            bd[y][x]=0;
          }
          write--;
        }
      }
    }
  }

  // ===== 描画 =====
  function draw(highlightSet=null, highlightAlpha=1){
    // 背景
    ctx.clearRect(0,0,boardCanvas.width,boardCanvas.height);
    ctx.save();
    // フィールドグリッド
    for (let y=0;y<ROWS;y++){
      for (let x=0;x<COLS;x++){
        const gx = x*CELL, gy=y*CELL;
        ctx.fillStyle = ((x+y)&1) ? '#101010' : '#0d0d0d';
        ctx.fillRect(gx,gy,CELL,CELL);
        ctx.strokeStyle = '#111';
        ctx.lineWidth = 1;
        ctx.strokeRect(gx+0.5,gy+0.5,CELL-1,CELL-1);
      }
    }
    // 盤面ぷよ
    for (let y=0;y<ROWS;y++){
      for (let x=0;x<COLS;x++){
        const color = board[y][x];
        if (color!==0){
          const alpha = (highlightSet && highlightSet.has(`${y},${x}`)) ? highlightAlpha : 1.0;
          drawPuyo(x,y,color,alpha);
        }
      }
    }
    // アクティブ
    if (active && !clearing){
      const parts = getPieces(active);
      for (const p of parts){
        if (p.y>=0) drawPuyo(p.x,p.y,p.color,1.0,true);
      }
    }
    ctx.restore();
  }

  function drawPuyo(cx,cy,color,alpha=1.0,active=false){
    const x = cx*CELL, y=cy*CELL;
    const r = CELL*0.44;
    ctx.save();
    ctx.globalAlpha = alpha;
    // 本体
    ctx.beginPath();
    ctx.arc(x+CELL/2, y+CELL/2, r, 0, Math.PI*2);
    ctx.closePath();
    ctx.fillStyle = COLOR_TABLE[color] || '#888';
    ctx.fill();
    // ハイライト
    ctx.beginPath();
    ctx.arc(x+CELL/2 - r*0.35, y+CELL/2 - r*0.35, r*0.35, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,.18)';
    ctx.fill();
    // 外枠
    ctx.lineWidth = active ? 2.2 : 1.2;
    ctx.strokeStyle = 'rgba(0,0,0,.35)';
    ctx.stroke();
    ctx.restore();
  }

  function drawNext(){
    const w = nextCanvas.width, h = nextCanvas.height;
    nctx.clearRect(0,0,w,h);
    // 2個を縦並び表示
    const sz = 20;
    const ox = w/2, oy = h/2 - 12;
    const render = (px,py,color) => {
      nctx.beginPath();
      nctx.arc(px, py, sz, 0, Math.PI*2);
      nctx.fillStyle = COLOR_TABLE[color] || '#888';
      nctx.fill();
      nctx.lineWidth = 2;
      nctx.strokeStyle = 'rgba(0,0,0,.35)';
      nctx.stroke();
      nctx.beginPath();
      nctx.arc(px - sz*0.35, py - sz*0.35, sz*0.35, 0, Math.PI*2);
      nctx.fillStyle = 'rgba(255,255,255,.18)';
      nctx.fill();
    };
    render(ox, oy, nextPair[0]);
    render(ox, oy+44, nextPair[1]);
  }

  function showChainPop(n){
    popEl.textContent = n>=2 ? `${n} 連鎖！` : 'CLEAR!';
    popEl.classList.remove('show');
    void popEl.offsetWidth; // reflow
    popEl.classList.add('show');
    setTimeout(()=> popEl.classList.remove('show'), 800);
  }

  // ===== ループ =====
  function loop(ts){
    if (!playing) { lastTime = ts || 0; requestAnimationFrame(loop); return; }
    if (paused || clearing) { lastTime = ts || 0; requestAnimationFrame(loop); return; }
    if (!lastTime) lastTime = ts;
    const dt = ts - lastTime;
    lastTime = ts;

    dropTimer += dt;
    const interval = dropInterval;
    if (dropTimer >= interval){
      dropTimer = 0;
      if (!collides(active,0,1,active.orient)) {
        active.y += 1;
        draw();
      } else {
        lockAndResolve();
      }
    }

    requestAnimationFrame(loop);
  }

  // ===== 入力 =====
  const keyState = new Set();
  window.addEventListener('keydown', (e)=>{
    if (['ArrowLeft','ArrowRight','ArrowDown','ArrowUp',' ','Space','KeyZ','KeyX'].includes(e.code) || ['ArrowLeft','ArrowRight','ArrowDown','ArrowUp',' '].includes(e.key)) {
      e.preventDefault();
    }
    if (e.repeat) return;
    keyState.add(e.code || e.key);
    switch(e.code){
      case 'ArrowLeft': move(-1); break;
      case 'ArrowRight': move(1); break;
      case 'ArrowUp':
      case 'KeyX': rotate(+1); break;
      case 'KeyZ': rotate(-1); break;
      case 'Space': hardDrop(); break;
      case 'ArrowDown':
        dropInterval = SOFTDROP_MS;
        break;
    }
  });
  window.addEventListener('keyup', (e)=>{
    keyState.delete(e.code || e.key);
    if (e.code === 'ArrowDown') {
      dropInterval = GRAVITY_MS;
    }
  });

  // モバイルボタン（単発動作）
  mLeft.addEventListener('click', ()=> move(-1));
  mRight.addEventListener('click', ()=> move(1));
  mRotL.addEventListener('click', ()=> rotate(-1));
  mRotR.addEventListener('click', ()=> rotate(+1));
  mDown.addEventListener('mousedown', ()=> { dropInterval = SOFTDROP_MS; });
  mDown.addEventListener('touchstart', ()=> { dropInterval = SOFTDROP_MS; }, {passive:true});
  const stopSoft = ()=> { dropInterval = GRAVITY_MS; };
  mDown.addEventListener('mouseup', stopSoft);
  mDown.addEventListener('mouseleave', stopSoft);
  mDown.addEventListener('touchend', stopSoft);
  mHard.addEventListener('click', hardDrop);

  // ボタン
  btnNew.addEventListener('click', ()=> reset());
  btnRestart.addEventListener('click', ()=> reset());
  btnPause.addEventListener('click', ()=>{
    if (!playing || gameover) return;
    paused = !paused;
    btnPause.textContent = paused ? '再開' : '一時停止';
  });
  btnHard.addEventListener('click', hardDrop);

  // 起動
  reset();
  requestAnimationFrame(loop);

  // リサイズ時の見た目（CSS任せ、論理サイズは据え置き）
  window.addEventListener('resize', ()=> {
    // キャンバスはCSSスケールのみ。論理ピクセルは固定でOK。
    draw();
  });
})();
</script>
</body>
</html>
